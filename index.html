<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>No-Guess Minesweeper</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --cell-hidden: #b0bec5;
            --cell-revealed: #e0e0e0;
            --cell-hover: #cfd8dc;
            --accent: #2196f3;
            --text: #37474f;
            --shadow: rgba(0,0,0,0.1);
        }
        
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none; /* Crucial for custom touch handling */
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            box-shadow: 0 4px 6px var(--shadow);
            border-radius: 4px;
        }

        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            pointer-events: none;
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .hud-panel {
            background: white;
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 2px 4px var(--shadow);
            font-weight: bold;
            color: var(--text);
            pointer-events: auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #game-over-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            text-align: center;
            z-index: 100;
        }

        #game-over-modal h2 {
            margin-top: 0;
            color: var(--text);
        }

        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        button:active {
            opacity: 0.8;
        }

        .loading-spinner {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 50;
            background: rgba(255,255,255,0.8);
            padding: 20px;
            border-radius: 8px;
            font-weight: bold;
        }
        
        /* Disable context menu specifically for the canvas */
        canvas {
            -webkit-touch-callout: none;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-overlay">
        <div class="hud-panel">
            <span>üí£</span> <span id="mine-count">15</span>
        </div>
        <div class="hud-panel">
            <span>‚è±Ô∏è</span> <span id="timer">0</span>
        </div>
    </div>

    <div id="loading" class="loading-spinner">Generating No-Guess Board...</div>

    <div id="game-over-modal">
        <h2 id="modal-title">Game Over</h2>
        <p id="modal-message">Better luck next time!</p>
        <button id="restart-btn">New Game</button>
    </div>
</div>

<script>
/**
 * INFINITE NO-GUESS MINESWEEPER
 * Chunk-based Architecture
 */

// --- CONFIGURATION ---
const CHUNK_SIZE = 10;
const TILE_SIZE = 50;
const BASE_DENSITY = 0.15;
const MAX_DENSITY = 0.38;
const DENSITY_GROWTH = 0.10; // 10% increase per chunk

const COLORS = {
    hidden: '#90A4AE',
    revealed: '#ECEFF1',
    border: '#ffffff',
    text: '#37474f',
    flag: '#e53935',
    mine: '#263238',
    highlight: '#CFD8DC',
    fog: '#cfd8dc', // Background for empty space
    nums: ['', '#1976D2', '#388E3C', '#D32F2F', '#7B1FA2', '#FF8F00', '#0097A7', '#424242', '#E91E63']
};

// --- GAME STATE ---
const chunks = new Map(); // Key: "cx,cy", Value: Chunk Object
let activeChunkKey = null; // The chunk currently being played
let solvedChunks = 0;
let isGameOver = false;
let startTime = 0;
let timerInterval = null;

// Camera / Input
let camera = { x: 0, y: 0, scale: 1.0 };
let input = {
    isDragging: false,
    lastX: 0, lastY: 0,
    pointers: new Map(),
    longPressTimer: null,
    isLongPress: false,
    clickStartCamera: {x:0, y:0}
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const dpr = window.devicePixelRatio || 1;

// --- DATA STRUCTURES ---

class Chunk {
    constructor(cx, cy, density) {
        this.cx = cx;
        this.cy = cy;
        this.density = density;
        this.isSolved = false;
        this.isGenerated = false; // New flag
        this.grid = []; 
        this.initGrid();
    }

    initGrid() {
        for (let r = 0; r < CHUNK_SIZE; r++) {
            let row = [];
            for (let c = 0; c < CHUNK_SIZE; c++) {
                row.push({
                    r: r, c: c, 
                    gr: this.cy * CHUNK_SIZE + r, 
                    gc: this.cx * CHUNK_SIZE + c,
                    isMine: false,
                    isRevealed: false,
                    isFlagged: false,
                    neighborMines: 0
                });
            }
            this.grid.push(row);
        }
    }

    get(r, c) {
        if (r >= 0 && r < CHUNK_SIZE && c >= 0 && c < CHUNK_SIZE) {
            return this.grid[r][c];
        }
        return null;
    }
}

// --- INITIALIZATION ---

function init() {
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    setupInput();
    resetGame();
    requestAnimationFrame(render);
}

function resizeCanvas() {
    const container = document.getElementById('game-container');
    canvas.width = container.clientWidth * dpr;
    canvas.height = container.clientHeight * dpr;
    canvas.style.width = container.clientWidth + 'px';
    canvas.style.height = container.clientHeight + 'px';
    ctx.scale(dpr, dpr);
}

function resetGame() {
    isGameOver = false;
    solvedChunks = 0;
    chunks.clear();
    stopTimer();
    document.getElementById('timer').innerText = '0';
    document.getElementById('mine-count').innerText = '-';
    document.getElementById('game-over-modal').style.display = 'none';

    // Spawn First Chunk at 0,0
    spawnChunk(0, 0, true);
    centerCameraOnChunk(0, 0);
}

function centerCameraOnChunk(cx, cy) {
    const chunkPx = CHUNK_SIZE * TILE_SIZE;
    const screenW = canvas.width / dpr;
    const screenH = canvas.height / dpr;
    
    const targetX = (cx * CHUNK_SIZE * TILE_SIZE) + (chunkPx / 2);
    const targetY = (cy * CHUNK_SIZE * TILE_SIZE) + (chunkPx / 2);

    const targetScale = Math.min(screenW / (chunkPx + 100), screenH / (chunkPx + 100), 1.2);
    
    camera.scale = targetScale;
    camera.x = (screenW / 2) - (targetX * camera.scale);
    camera.y = (screenH / 2) - (targetY * camera.scale);
}

// --- CHUNK MANAGEMENT ---

function getGlobalCell(gr, gc) {
    const cx = Math.floor(gc / CHUNK_SIZE);
    const cy = Math.floor(gr / CHUNK_SIZE);
    const chunk = chunks.get(`${cx},${cy}`);
    if (!chunk) return null;
    
    const r = ((gr % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    const c = ((gc % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    
    return chunk.get(r, c);
}

function spawnChunk(cx, cy, isFirst) {
    const density = Math.min(MAX_DENSITY, BASE_DENSITY * Math.pow(1 + DENSITY_GROWTH, solvedChunks));
    const chunk = new Chunk(cx, cy, density);
    chunks.set(`${cx},${cy}`, chunk);
    activeChunkKey = `${cx},${cy}`;

    if (isFirst) {
        // Defer generation until first click
        // Chunk exists but is blank. 
        // We do NOT call generateChunk here.
    } else {
        document.getElementById('loading').style.display = 'block';
        setTimeout(() => {
            generateChunk(chunk, false).then(success => {
                document.getElementById('loading').style.display = 'none';
                if (success) {
                    chunk.isGenerated = true;
                    // Auto-reveal seam logic could go here if we wanted seamless flow without click,
                    // but for now, we rely on the player reaching it? 
                    // Actually, for infinite expansion, usually the new chunk is revealed immediately 
                    // where it touches the old one?
                    // For this prototype, let's keep it simple: Hidden until revealed? 
                    // Wait, the requirement was "Stitched... transition...". 
                    // If we don't reveal the seam, the user has to guess where to enter?
                    // Ah, `generateChunk` ensures logical solvability FROM the edge.
                    // But the user still needs to click a safe cell. 
                    // Usually, we should auto-reveal safe cells adjacent to the opening.
                    // Let's add that for non-first chunks.
                    revealSeam(chunk);
                } else {
                    console.error("Failed to generate valid chunk");
                }
            });
        }, 50);
    }
}

function revealSeam(chunk) {
    // Reveal any cells in the new chunk that are guaranteed safe by the solver logic
    // or just the ones adjacent to the trigger?
    // The safest bet for "No Guess" flow is to reveal cells that are 0-neighbors of existing 0s?
    // Or just let the solver's 'revealed' state guide us. 
    // For now, let's stick to user interaction except for the "First Click".
    // Actually, if we don't reveal anything, the user sees a blank 10x10 grid next to their solved one.
    // They click the border?
    // Let's just update HUD.
    updateHUD();
}

async function generateChunk(chunk, isFirst, startR = 0, startC = 0) {
    const maxAttempts = 200;
    const totalCells = CHUNK_SIZE * CHUNK_SIZE;
    const targetMines = Math.floor(totalCells * chunk.density);

    for (let attempt = 0; attempt < maxAttempts; attempt++) {
        // Reset Local
        chunk.grid.forEach(row => row.forEach(c => {
            c.isMine = false;
            c.isRevealed = false;
            c.isFlagged = false;
            c.neighborMines = 0;
        }));

        let minesPlaced = 0;
        const safeSet = new Set();
        
        if (isFirst) {
            // Reserve Start cell AND neighbors
            safeSet.add(`${startR},${startC}`);
            for(let dr=-1; dr<=1; dr++){
                for(let dc=-1; dc<=1; dc++){
                    const nr = startR+dr; 
                    const nc = startC+dc;
                    if(nr>=0 && nr<CHUNK_SIZE && nc>=0 && nc<CHUNK_SIZE){
                        safeSet.add(`${nr},${nc}`);
                    }
                }
            }
        }

        // Random Placement
        while (minesPlaced < targetMines) {
            const r = Math.floor(Math.random() * CHUNK_SIZE);
            const c = Math.floor(Math.random() * CHUNK_SIZE);
            if (!chunk.grid[r][c].isMine && !safeSet.has(`${r},${c}`)) {
                chunk.grid[r][c].isMine = true;
                minesPlaced++;
            }
        }

        calculateNumbers(chunk);

        if (!checkBoundaryConsistency(chunk)) continue;

        if (checkChunkSolvability(chunk, isFirst, startR, startC)) {
            return true;
        }
    }
    return false;
}

// ... calculateNumbers, countGlobalMines, checkBoundaryConsistency remain same ...
function calculateNumbers(chunk) {
    chunk.grid.forEach(row => row.forEach(cell => {
        if (!cell.isMine) {
            cell.neighborMines = countGlobalMines(cell.gr, cell.gc);
        }
    }));
}
function countGlobalMines(gr, gc) {
    let count = 0;
    for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            const n = getGlobalCell(gr + dr, gc + dc);
            if (n && n.isMine) count++;
        }
    }
    return count;
}
function checkBoundaryConsistency(chunk) {
    const deltas = [[0, -1], [0, 1], [-1, 0], [1, 0]]; 
    for (let [dcy, dcx] of deltas) {
        const neighborChunk = chunks.get(`${chunk.cx + dcx},${chunk.cy + dcy}`);
        if (!neighborChunk) continue;
        let rStart = 0, rEnd = CHUNK_SIZE, cStart = 0, cEnd = CHUNK_SIZE;
        if (dcx === -1) { cStart = CHUNK_SIZE-1; cEnd = CHUNK_SIZE; } 
        if (dcx === 1)  { cStart = 0; cEnd = 1; } 
        if (dcy === -1) { rStart = CHUNK_SIZE-1; rEnd = CHUNK_SIZE; } 
        if (dcy === 1)  { rStart = 0; rEnd = 1; } 
        for (let r = rStart; r < rEnd; r++) {
            for (let c = cStart; c < cEnd; c++) {
                const nCell = neighborChunk.grid[r][c];
                if (nCell.isRevealed && !nCell.isMine) {
                    const currentCount = countGlobalMines(nCell.gr, nCell.gc);
                    if (currentCount !== nCell.neighborMines) return false;
                }
            }
        }
    }
    return true;
}


// --- SOLVER ---

function checkChunkSolvability(chunk, isFirst, startR, startC) {
    const state = chunk.grid.map(row => row.map(c => ({
        ...c,
        status: 'hidden'
    })));

    // Initial Moves
    
    if (isFirst) {
        // Start from the user's click
        vReveal(state[startR][startC]);
    } else {
        // For non-first chunks, we don't have a "start click".
        // The solver logic must proceed entirely from the "Seam" (external revealed cells).
        // So we just init the loop.
    }

    function getVCell(gr, gc) {
        const localR = gr - (chunk.cy * CHUNK_SIZE);
        const localC = gc - (chunk.cx * CHUNK_SIZE);
        if (localR >= 0 && localR < CHUNK_SIZE && localC >= 0 && localC < CHUNK_SIZE) {
            return state[localR][localC];
        }
        const real = getGlobalCell(gr, gc);
        if (real) {
            return {
                ...real,
                status: real.isRevealed ? 'revealed' : (real.isFlagged ? 'flagged' : 'hidden'),
                isExternal: true
            };
        }
        return null;
    }

    function getVNeighbors(vCell) {
        const res = [];
        for(let dr=-1; dr<=1; dr++){
            for(let dc=-1; dc<=1; dc++){
                if(dr===0 && dc===0) continue;
                const n = getVCell(vCell.gr + dr, vCell.gc + dc);
                if(n) res.push(n);
            }
        }
        return res;
    }

    function vReveal(vc) {
        if (vc.status !== 'hidden') return;
        vc.status = 'revealed';
        if (vc.isMine) return; 
        if (vc.neighborMines === 0) {
            getVNeighbors(vc).forEach(n => !n.isExternal && vReveal(n));
        }
    }

    let progress = true;
    while (progress) {
        progress = false;
        let changed = false;

        const cellsToCheck = [];
        state.flat().forEach(c => {
            if (c.status === 'revealed') cellsToCheck.push(c);
        });

        const deltas = [[0, -1], [0, 1], [-1, 0], [1, 0]];
        deltas.forEach(([dcy, dcx]) => {
            const nc = chunks.get(`${chunk.cx+dcx},${chunk.cy+dcy}`);
            if(nc) {
                nc.grid.flat().forEach(real => {
                    if (real.isRevealed && isTouchingChunk(real, chunk)) {
                         cellsToCheck.push({
                             ...real,
                             status: 'revealed',
                             isExternal: true
                         });
                    }
                });
            }
        });

        for (let cell of cellsToCheck) {
            if (cell.neighborMines > 0) {
                const neighbors = getVNeighbors(cell);
                const hidden = neighbors.filter(n => n.status === 'hidden');
                const flagged = neighbors.filter(n => n.status === 'flagged');
                
                if (hidden.length === 0) continue;

                if (flagged.length === cell.neighborMines) {
                    hidden.forEach(n => {
                        if (!n.isExternal) { vReveal(n); changed = true; }
                    });
                } else if (hidden.length + flagged.length === cell.neighborMines) {
                    hidden.forEach(n => {
                        if (!n.isExternal) { n.status = 'flagged'; changed = true; }
                    });
                }
            }
        }

        if (changed) {
            progress = true; 
            continue;
        }

        if (runTankSolver(state, getVNeighbors)) {
            progress = true;
        }
    }

    for (let r = 0; r < CHUNK_SIZE; r++) {
        for (let c = 0; c < CHUNK_SIZE; c++) {
            if (state[r][c].status === 'hidden' && !state[r][c].isMine) return false;
        }
    }
    return true;
}

// ... isTouchingChunk, runTankSolver, hasRevealedNeighbor remain same ...
function isTouchingChunk(cell, chunk) {
    const minGr = chunk.cy * CHUNK_SIZE;
    const maxGr = minGr + CHUNK_SIZE - 1;
    const minGc = chunk.cx * CHUNK_SIZE;
    const maxGc = minGc + CHUNK_SIZE - 1;
    return (cell.gr >= minGr - 1 && cell.gr <= maxGr + 1 &&
            cell.gc >= minGc - 1 && cell.gc <= maxGc + 1);
}

function runTankSolver(state, getNeighborsFunc) {
    const boundary = new Set();
    const constraints = [];
    const relevantCells = []; 
    
    state.flat().forEach(c => { if(c.status === 'revealed') relevantCells.push(c); });
    
    const cx = Math.floor(state[0][0].gc / CHUNK_SIZE);
    const cy = Math.floor(state[0][0].gr / CHUNK_SIZE);
    
    [[0, -1], [0, 1], [-1, 0], [1, 0]].forEach(([dcy, dcx]) => {
        const nc = chunks.get(`${cx+dcx},${cy+dcy}`);
        if(nc) {
            nc.grid.flat().forEach(real => {
                if (real.isRevealed && isTouchingChunk(real, {cx, cy})) {
                     relevantCells.push({...real, status: 'revealed', isExternal: true});
                }
            });
        }
    });

    for(let cell of relevantCells){
        if(cell.neighborMines > 0){
            const neighbors = getNeighborsFunc(cell);
            const hidden = neighbors.filter(n => n.status === 'hidden' && !n.isExternal); 
            const flagged = neighbors.filter(n => n.status === 'flagged');
            
            if(hidden.length > 0){
                hidden.forEach(h => boundary.add(h));
                constraints.push({
                    cell: cell,
                    needed: cell.neighborMines - flagged.length,
                    targets: hidden
                });
            }
        }
    }

    if(boundary.size === 0) return false;
    
    const boundaryList = Array.from(boundary);
    const bMap = new Map();
    boundaryList.forEach((b, i) => bMap.set(b, i));
    const optConstraints = constraints.map(k => ({
        needed: k.needed,
        indices: k.targets.map(t => bMap.get(t))
    }));

    const canBeMine = new Array(boundaryList.length).fill(false);
    const canBeSafe = new Array(boundaryList.length).fill(false);
    const assignment = new Array(boundaryList.length).fill(-1);

    function solveRec(idx) {
        if(idx >= boundaryList.length){
            for(let i=0; i<boundaryList.length; i++){
                if(assignment[i] === 1) canBeMine[i] = true;
                else canBeSafe[i] = true;
            }
            return true;
        }
        assignment[idx] = 0;
        if(isValid(idx)) solveRec(idx + 1);
        assignment[idx] = 1;
        if(isValid(idx)) solveRec(idx + 1);
        assignment[idx] = -1;
    }

    function isValid(uptoIdx) {
        for(let k of optConstraints){
            let placed = 0;
            let unknown = 0;
            for(let idx of k.indices){
                if(assignment[idx] === 1) placed++;
                else if(assignment[idx] === -1) unknown++;
            }
            if(placed > k.needed) return false;
            if(placed + unknown < k.needed) return false;
        }
        return true;
    }

    solveRec(0);

    let madeProgress = false;
    for(let i=0; i<boundaryList.length; i++){
        const cell = boundaryList[i];
        if(canBeMine[i] && !canBeSafe[i]){
            cell.status = 'flagged';
            madeProgress = true;
        } else if(!canBeMine[i] && canBeSafe[i]){
            cell.status = 'revealed'; 
            madeProgress = true;
        }
    }
    return madeProgress;
}

// --- GAMEPLAY HELPERS ---

function hasRevealedNeighbor(gr, gc) {
    for(let dr=-1; dr<=1; dr++){
        for(let dc=-1; dc<=1; dc++){
            if(dr===0 && dc===0) continue;
            const n = getGlobalCell(gr+dr, gc+dc);
            if(n && n.isRevealed) return true;
        }
    }
    return false;
}

function handleTap(r, c, isLong) {
    if (isGameOver) return;
    
    const cell = getGlobalCell(r, c);
    if (!cell) return; 

    // FIRST CLICK GENERATION
    const chunk = chunks.get(`${Math.floor(c/CHUNK_SIZE)},${Math.floor(r/CHUNK_SIZE)}`);
    if (chunk && !chunk.isGenerated && !isLong) {
        document.getElementById('loading').style.display = 'block';
        // Force async to let UI draw loading
        setTimeout(() => {
            // Local coords
            const localR = cell.r; 
            const localC = cell.c;
            
            generateChunk(chunk, true, localR, localC).then(success => {
                document.getElementById('loading').style.display = 'none';
                if (success) {
                    chunk.isGenerated = true;
                    // Start timer
                    startTimer();
                    // Reveal the clicked cell (safe start)
                    reveal(cell);
                } else {
                    alert("Failed to generate solvable start. Please try again.");
                }
            });
        }, 10);
        return;
    }

    if (isLong) {
        if (!cell.isRevealed) toggleFlag(cell);
        return;
    }

    if (cell.isFlagged) return;
    if (cell.isRevealed) tryChording(cell);
    else reveal(cell);
}

function toggleFlag(cell) {
    cell.isFlagged = !cell.isFlagged;
    // Vibration
    if (navigator.vibrate) navigator.vibrate(50);
}

function reveal(cell) {
    if (cell.isRevealed || cell.isFlagged) return;
    
    cell.isRevealed = true;
    
    if (cell.isMine) {
        gameOver(false);
        return;
    }

    if (cell.neighborMines === 0) {
        // Flood Fill (Global)
        const stack = [cell];
        while (stack.length > 0) {
            const current = stack.pop();
            // Get neighbors
            for(let dr=-1; dr<=1; dr++){
                for(let dc=-1; dc<=1; dc++){
                    if(dr===0 && dc===0) continue;
                    const n = getGlobalCell(current.gr + dr, current.gc + dc);
                    if (n && !n.isRevealed && !n.isFlagged) {
                        n.isRevealed = true;
                        if (n.neighborMines === 0) stack.push(n);
                    }
                }
            }
        }
    }
    
    checkChunkComplete(cell);
}

function tryChording(cell) {
    let flags = 0;
    const neighbors = [];
    
    for(let dr=-1; dr<=1; dr++){
        for(let dc=-1; dc<=1; dc++){
            if(dr===0 && dc===0) continue;
            const n = getGlobalCell(cell.gr + dr, cell.gc + dc);
            if (n) {
                neighbors.push(n);
                if (n.isFlagged) flags++;
            }
        }
    }

    if (flags === cell.neighborMines) {
        neighbors.forEach(n => {
            if (!n.isRevealed && !n.isFlagged) reveal(n);
        });
    }
}

function checkChunkComplete(lastCell) {
    // Check if the current chunk is solved
    const chunk = chunks.get(`${Math.floor(lastCell.gc/CHUNK_SIZE)},${Math.floor(lastCell.gr/CHUNK_SIZE)}`);
    if (!chunk || chunk.isSolved) return;

    // A chunk is solved if all non-mine cells are revealed
    let unrevealedSafe = 0;
    chunk.grid.flat().forEach(c => {
        if (!c.isMine && !c.isRevealed) unrevealedSafe++;
    });

    if (unrevealedSafe === 0) {
        chunk.isSolved = true;
        solvedChunks++;
        
        // Flag all mines in this chunk for aesthetics
        chunk.grid.flat().forEach(c => {
            if (c.isMine) c.isFlagged = true;
        });

        // SPAWN NEXT CHUNK
        // Pick random direction (N, S, E, W) that is empty
        const directions = [[0, -1], [0, 1], [-1, 0], [1, 0]];
        const candidates = directions.filter(([dcy, dcx]) => {
            return !chunks.has(`${chunk.cx + dcx},${chunk.cy + dcy}`);
        });

        if (candidates.length > 0) {
            const [dcy, dcx] = candidates[Math.floor(Math.random() * candidates.length)];
            const newCx = chunk.cx + dcx;
            const newCy = chunk.cy + dcy;
            spawnChunk(newCx, newCy, false);
            
            // Pan Camera
            // Simple ease to new center
            // (In a real app we'd use a tween library, here we just snap or rely on user panning? 
            // Requirement said "Smooth Panning". Let's do a simple interval lerp)
            panToChunk(newCx, newCy);
        }
        
        updateHUD();
    }
}

function panToChunk(cx, cy) {
    // Target
    const chunkPx = CHUNK_SIZE * TILE_SIZE;
    const screenW = canvas.width / dpr;
    const screenH = canvas.height / dpr;
    const tx = (screenW/2) - ((cx * chunkPx + chunkPx/2) * camera.scale);
    const ty = (screenH/2) - ((cy * chunkPx + chunkPx/2) * camera.scale);
    
    // Animate
    let frames = 0;
    const maxFrames = 60; // 1 sec
    const sx = camera.x;
    const sy = camera.y;
    
    function step() {
        frames++;
        const t = frames / maxFrames;
        const ease = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; // Ease in out
        
        camera.x = sx + (tx - sx) * ease;
        camera.y = sy + (ty - sy) * ease;
        
        if (frames < maxFrames) requestAnimationFrame(step);
    }
    step();
}

function gameOver(win) {
    isGameOver = true;
    stopTimer();
    
    // Reveal all mines in active chunks
    chunks.forEach(chunk => {
        chunk.grid.flat().forEach(cell => {
            if (cell.isMine && !cell.isFlagged) cell.isRevealed = true;
        });
    });

    const modal = document.getElementById('game-over-modal');
    document.getElementById('modal-title').innerText = "Game Over";
    document.getElementById('modal-message').innerText = `Cleared ${solvedChunks} Sectors`;
    document.getElementById('restart-btn').innerText = "Try Again";
    modal.style.display = 'block';
}

function startTimer() {
    if (timerInterval) return;
    startTime = Date.now();
    timerInterval = setInterval(() => {
        // Just show generic time or "Chunks Cleared" maybe?
        // Let's stick to time.
        const delta = Math.floor((Date.now() - startTime) / 1000);
        document.getElementById('timer').innerText = delta;
    }, 1000);
}

function stopTimer() {
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = null;
}

function updateHUD() {
    document.getElementById('mine-count').innerText = `Sectors: ${solvedChunks}`;
}

// --- RENDER LOOP ---

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    ctx.save();
    ctx.translate(camera.x, camera.y);
    ctx.scale(camera.scale, camera.scale);

    // Culling: Only draw visible chunks
    // Get viewport in world coords
    const screenW = canvas.width / dpr / camera.scale;
    const screenH = canvas.height / dpr / camera.scale;
    const viewX = -camera.x / camera.scale;
    const viewY = -camera.y / camera.scale;
    
    // Draw Chunks
    chunks.forEach(chunk => {
        // Simple culling
        const chX = chunk.cx * CHUNK_SIZE * TILE_SIZE;
        const chY = chunk.cy * CHUNK_SIZE * TILE_SIZE;
        const chSize = CHUNK_SIZE * TILE_SIZE;
        
        if (chX + chSize < viewX || chX > viewX + screenW ||
            chY + chSize < viewY || chY > viewY + screenH) {
            return;
        }

        // Draw Chunk Background
        ctx.fillStyle = chunk.isSolved ? '#ffffff' : '#f0f2f5';
        ctx.fillRect(chX, chY, chSize, chSize);

        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = 'bold 24px sans-serif';
        
        chunk.grid.forEach(row => row.forEach(cell => {
            const x = cell.gc * TILE_SIZE;
            const y = cell.gr * TILE_SIZE;
            
            ctx.fillStyle = cell.isRevealed ? COLORS.revealed : COLORS.hidden;
            if (cell.isRevealed && cell.isMine) ctx.fillStyle = '#ef9a9a';
            ctx.fillRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);
            
            if (cell.isRevealed) {
                if (cell.isMine) {
                    ctx.fillStyle = COLORS.mine;
                    ctx.fillText('üí£', x + TILE_SIZE/2, y + TILE_SIZE/2 + 2);
                } else if (cell.neighborMines > 0) {
                    ctx.fillStyle = COLORS.nums[cell.neighborMines] || '#000';
                    ctx.fillText(cell.neighborMines, x + TILE_SIZE/2, y + TILE_SIZE/2 + 2);
                }
            } else if (cell.isFlagged) {
                 ctx.fillText('üö©', x + TILE_SIZE/2, y + TILE_SIZE/2 + 2);
            }
        }));
        
        // Debug: Draw Chunk Border
        ctx.strokeStyle = '#cfd8dc';
        ctx.lineWidth = 2;
        ctx.strokeRect(chX, chY, chSize, chSize);
    });

    ctx.restore();
    requestAnimationFrame(render);
}

// --- INPUT (Adapters) ---
// Note: Pointer logic remains mostly the same, but handlePointerUp calls handleTap
// with Global Coordinates.

function setupInput() {
    canvas.addEventListener('touchstart', onTouchStart, {passive: false});
    canvas.addEventListener('touchmove', onTouchMove, {passive: false});
    canvas.addEventListener('touchend', onTouchEnd, {passive: false});
    canvas.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('contextmenu', e => { e.preventDefault(); return false; });
    document.getElementById('restart-btn').addEventListener('click', resetGame);
}

// ... Copy existing pointer logic, ensuring handleTap gets correct coords ...
// Reuse the Input functions from original, but update the coord calc.

function onTouchStart(e) {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        input.pointers.set(t.identifier, {x: t.clientX, y: t.clientY, startX: t.clientX, startY: t.clientY});
    }
    handlePointerDown();
}
function onTouchMove(e) {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        const p = input.pointers.get(t.identifier);
        if(p) { p.x = t.clientX; p.y = t.clientY; }
    }
    handlePointerMove();
}
function onTouchEnd(e) {
    e.preventDefault();
    handlePointerUp(); 
    for (let i = 0; i < e.changedTouches.length; i++) {
        input.pointers.delete(e.changedTouches[i].identifier);
    }
    if (input.pointers.size === 0) input.isDragging = false;
}
function onMouseDown(e) {
    if(e.button !== 0 && e.button !== 2) return;
    input.pointers.set(999, {x: e.clientX, y: e.clientY, startX: e.clientX, startY: e.clientY});
    handlePointerDown();
    if (e.button === 2) {
        input.isLongPress = true; 
        clearTimeout(input.longPressTimer);
    }
}
function onMouseMove(e) {
    const p = input.pointers.get(999);
    if(p) { p.x = e.clientX; p.y = e.clientY; handlePointerMove(); }
}
function onMouseUp(e) {
    if(input.pointers.has(999)) {
        handlePointerUp();
        input.pointers.delete(999);
        input.isDragging = false;
    }
}

function handlePointerDown() {
    if (input.pointers.size === 1) {
        input.isDragging = false;
        input.clickStartCamera = { ...camera };
        input.isLongPress = false;
        const p = Array.from(input.pointers.values())[0]; 
        
        input.longPressTimer = setTimeout(() => {
            if (!input.isDragging) {
                input.isLongPress = true;
                const wx = (p.x - camera.x) / camera.scale;
                const wy = (p.y - camera.y) / camera.scale;
                const c = Math.floor(wx / TILE_SIZE);
                const r = Math.floor(wy / TILE_SIZE);
                handleTap(r, c, true); 
                if (navigator.vibrate) navigator.vibrate(20);
            }
        }, 250); 
    } else if (input.pointers.size === 2) {
        clearTimeout(input.longPressTimer);
        input.isDragging = true;
        input.baseDist = getPinchDist();
        input.baseScale = camera.scale;
    }
}

function handlePointerMove() {
    const ptrs = Array.from(input.pointers.values());
    if (input.pointers.size === 1) {
        const p = ptrs[0];
        const dx = p.x - p.startX;
        const dy = p.y - p.startY;
        if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
            clearTimeout(input.longPressTimer);
            input.isDragging = true;
            camera.x += (p.x - input.lastX);
            camera.y += (p.y - input.lastY);
        }
        input.lastX = p.x;
        input.lastY = p.y;
    } else if (input.pointers.size === 2) {
        const dist = getPinchDist();
        const center = getPinchCenter();
        const newScale = input.baseScale * (dist / input.baseDist);
        const clampedScale = Math.max(0.1, Math.min(newScale, 3.0)); // Allow zooming out more for infinite
        
        const oldScale = camera.scale;
        const scaleRatio = clampedScale / oldScale;
        
        const wx = (center.x - camera.x) / oldScale;
        const wy = (center.y - camera.y) / oldScale;
        
        camera.x = center.x - wx * clampedScale;
        camera.y = center.y - wy * clampedScale;
        camera.scale = clampedScale;

        input.lastX = center.x;
        input.lastY = center.y;
    }
}

function handlePointerUp() {
    clearTimeout(input.longPressTimer);
    if (!input.isDragging && input.pointers.size === 1 && !input.isLongPress) {
        const p = Array.from(input.pointers.values())[0];
        const wx = (p.x - camera.x) / camera.scale;
        const wy = (p.y - camera.y) / camera.scale;
        const c = Math.floor(wx / TILE_SIZE);
        const r = Math.floor(wy / TILE_SIZE);
        handleTap(r, c, false);
    }
}

function getPinchDist() {
    const ptrs = Array.from(input.pointers.values());
    return Math.hypot(ptrs[0].x - ptrs[1].x, ptrs[0].y - ptrs[1].y);
}
function getPinchCenter() {
    const ptrs = Array.from(input.pointers.values());
    return { x: (ptrs[0].x + ptrs[1].x)/2, y: (ptrs[0].y + ptrs[1].y)/2 };
}

init();
</script>
</body>
</html>
