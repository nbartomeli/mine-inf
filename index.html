<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>No-Guess Minesweeper</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --cell-hidden: #b0bec5;
            --cell-revealed: #e0e0e0;
            --cell-hover: #cfd8dc;
            --accent: #2196f3;
            --text: #37474f;
            --shadow: rgba(0,0,0,0.1);
        }
        
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none; /* Crucial for custom touch handling */
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            box-shadow: 0 4px 6px var(--shadow);
            border-radius: 4px;
        }

        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            pointer-events: none;
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .hud-panel {
            background: white;
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 2px 4px var(--shadow);
            font-weight: bold;
            color: var(--text);
            pointer-events: auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #game-over-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            text-align: center;
            z-index: 100;
        }

        #game-over-modal h2 {
            margin-top: 0;
            color: var(--text);
        }

        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        button:active {
            opacity: 0.8;
        }

        .loading-spinner {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 50;
            background: rgba(255,255,255,0.8);
            padding: 20px;
            border-radius: 8px;
            font-weight: bold;
        }
        
        /* Disable context menu specifically for the canvas */
        canvas {
            -webkit-touch-callout: none;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-overlay">
        <div class="hud-panel">
            <span>üí£</span> <span id="mine-count">15</span>
        </div>
        <div class="hud-panel">
            <span>‚è±Ô∏è</span> <span id="timer">0</span>
        </div>
    </div>

    <div id="loading" class="loading-spinner">Generating No-Guess Board...</div>

    <div id="game-over-modal">
        <h2 id="modal-title">Game Over</h2>
        <p id="modal-message">Better luck next time!</p>
        <button id="restart-btn">New Game</button>
    </div>
</div>

<script>
/**
 * INFINITE NO-GUESS MINESWEEPER
 * Chunk-based Architecture with Scaling
 */

// --- CONFIGURATION ---
const TILE_SIZE = 50;

const COLORS = {
    hidden: '#90A4AE',
    revealed: '#ECEFF1',
    border: '#ffffff',
    text: '#37474f',
    flag: '#e53935',
    mine: '#263238',
    highlight: '#CFD8DC',
    fog: '#cfd8dc', 
    nums: ['', '#1976D2', '#388E3C', '#D32F2F', '#7B1FA2', '#FF8F00', '#0097A7', '#424242', '#E91E63']
};

// --- GAME STATE ---
const chunks = []; // Array of chunks for iteration
let activeChunk = null; 
let solvedChunks = 0; // "Level" - 1
let totalChunksGenerated = 0; 
let isGameOver = false;
let startTime = 0;
let timerInterval = null;

// Camera / Input
let camera = { x: 0, y: 0, scale: 1.0 };
let input = {
    isDragging: false,
    lastX: 0, lastY: 0,
    pointers: new Map(),
    longPressTimer: null,
    isLongPress: false,
    clickStartCamera: {x:0, y:0}
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const dpr = window.devicePixelRatio || 1;

// --- DATA STRUCTURES ---

class Chunk {
    constructor(index, x, y, w, h, density) {
        this.index = index;
        this.x = x; // World Tile X (left)
        this.y = y; // World Tile Y (top)
        this.w = w;
        this.h = h;
        this.density = density;
        this.isSolved = false;
        this.isGenerated = false;
        this.grid = []; 
        this.initGrid();
    }

    initGrid() {
        for (let r = 0; r < this.h; r++) {
            let row = [];
            for (let c = 0; c < this.w; c++) {
                row.push({
                    r: r, c: c, 
                    gr: this.y + r, // Global Row
                    gc: this.x + c, // Global Col
                    isMine: false,
                    isRevealed: false,
                    isFlagged: false,
                    neighborMines: 0
                });
            }
            this.grid.push(row);
        }
    }

    contains(gr, gc) {
        return (gr >= this.y && gr < this.y + this.h && 
                gc >= this.x && gc < this.x + this.w);
    }

    get(r, c) {
        if (r >= 0 && r < this.h && c >= 0 && c < this.w) {
            return this.grid[r][c];
        }
        return null;
    }
}

// --- INITIALIZATION ---

function init() {
    setupUI();
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    setupInput();
    resetGame();
    requestAnimationFrame(render);
}

function setupUI() {
    const overlay = document.getElementById('ui-overlay');
    // Add new stats panel if not exists
    if (!document.getElementById('stats-panel')) {
        const stats = document.createElement('div');
        stats.id = 'stats-panel';
        stats.className = 'hud-panel';
        stats.style.flexDirection = 'column';
        stats.style.alignItems = 'flex-start';
        stats.style.fontSize = '12px';
        stats.innerHTML = `
            <div>Level: <span id="level-val">1</span></div>
            <div>Size: <span id="size-val">10x10</span></div>
            <div>Density: <span id="density-val">12%</span></div>
        `;
        overlay.appendChild(stats);
    }
}

function resizeCanvas() {
    const container = document.getElementById('game-container');
    canvas.width = container.clientWidth * dpr;
    canvas.height = container.clientHeight * dpr;
    canvas.style.width = container.clientWidth + 'px';
    canvas.style.height = container.clientHeight + 'px';
    ctx.scale(dpr, dpr);
}

function resetGame() {
    isGameOver = false;
    solvedChunks = 0;
    totalChunksGenerated = 0;
    chunks.length = 0;
    activeChunk = null;
    stopTimer();
    document.getElementById('timer').innerText = '0';
    document.getElementById('mine-count').innerText = '-';
    document.getElementById('game-over-modal').style.display = 'none';

    // Spawn First Chunk centered at 0,0 roughly
    // Starting params
    spawnChunk(null, 0, 0, true); 
}

function updateStatsHUD(chunk) {
    if (!chunk) return;
    document.getElementById('level-val').innerText = chunk.index + 1;
    document.getElementById('size-val').innerText = `${chunk.w}x${chunk.h}`;
    document.getElementById('density-val').innerText = `${Math.round(chunk.density * 100)}%`;
    document.getElementById('mine-count').innerText = `Sectors: ${solvedChunks}`;
}

// --- CHUNK MANAGEMENT ---

function getChunkAt(gr, gc) {
    // Linear scan is acceptable for <1000 chunks
    for (const chunk of chunks) {
        if (chunk.contains(gr, gc)) return chunk;
    }
    return null;
}

function getGlobalCell(gr, gc) {
    const chunk = getChunkAt(gr, gc);
    if (!chunk) return null;
    return chunk.grid[gr - chunk.y][gc - chunk.x];
}

function spawnChunk(parentChunk, dirX, dirY, isFirst) {
    // Progression Logic
    const index = totalChunksGenerated;
    // Density: 0.12 + (index * 0.02), Cap 0.38
    const density = Math.min(0.38, 0.12 + (index * 0.02));
    // Size: 10 + floor(index/2)*2, Cap 30
    const dim = Math.min(30, 10 + Math.floor(index / 2) * 2);
    
    let x, y, w, h;
    w = dim;
    h = dim;

    if (isFirst) {
        x = -Math.floor(w/2);
        y = -Math.floor(h/2);
    } else {
        // Calculate position relative to parent
        // Align centers
        const centerX = parentChunk.x + parentChunk.w/2;
        const centerY = parentChunk.y + parentChunk.h/2;
        
        // Direction vectors
        if (dirX === 1) { // East
            x = parentChunk.x + parentChunk.w;
            y = Math.floor(centerY - h/2);
        } else if (dirX === -1) { // West
            x = parentChunk.x - w;
            y = Math.floor(centerY - h/2);
        } else if (dirY === 1) { // South
            y = parentChunk.y + parentChunk.h;
            x = Math.floor(centerX - w/2);
        } else if (dirY === -1) { // North
            y = parentChunk.y - h;
            x = Math.floor(centerX - w/2);
        }
    }

    // Collision Check
    if (!checkSpaceAvailable(x, y, w, h)) {
        return false;
    }

    const chunk = new Chunk(index, x, y, w, h, density);
    chunks.push(chunk);
    activeChunk = chunk;
    totalChunksGenerated++;
    updateStatsHUD(chunk);

    if (isFirst) {
        centerCameraOnChunk(chunk);
    } else {
        // Defer generation
        document.getElementById('loading').style.display = 'block';
        setTimeout(() => {
            generateChunk(chunk, false).then(success => {
                document.getElementById('loading').style.display = 'none';
                if (success) {
                    chunk.isGenerated = true;
                    updateStatsHUD(chunk);
                }
            });
        }, 50);
    }
    return true;
}

function checkSpaceAvailable(x, y, w, h) {
    // Check overlap with existing chunks
    // Shrink rect slightly to allow touching edges? 
    // No, standard rect intersection. Touching edges is fine. Overlap is not.
    for (const c of chunks) {
        if (x < c.x + c.w && x + w > c.x &&
            y < c.y + c.h && y + h > c.y) {
            return false;
        }
    }
    return true;
}

function centerCameraOnChunk(chunk) {
    const screenW = canvas.width / dpr;
    const screenH = canvas.height / dpr;
    const chunkW = chunk.w * TILE_SIZE;
    const chunkH = chunk.h * TILE_SIZE;
    
    const cx = (chunk.x * TILE_SIZE) + chunkW/2;
    const cy = (chunk.y * TILE_SIZE) + chunkH/2;

    const targetScale = Math.min(screenW / (chunkW + 100), screenH / (chunkH + 100), 1.2);
    
    camera.scale = targetScale;
    camera.x = (screenW / 2) - (cx * camera.scale);
    camera.y = (screenH / 2) - (cy * camera.scale);
}

// --- GENERATOR ---

async function generateChunk(chunk, isFirst, startR = 0, startC = 0) {
    const maxAttempts = 200;
    const totalCells = chunk.w * chunk.h;
    const targetMines = Math.floor(totalCells * chunk.density);

    for (let attempt = 0; attempt < maxAttempts; attempt++) {
        // Reset
        chunk.grid.forEach(row => row.forEach(c => {
            c.isMine = false;
            c.isRevealed = false;
            c.isFlagged = false;
            c.neighborMines = 0;
        }));

        let minesPlaced = 0;
        const safeSet = new Set();
        
        if (isFirst) {
            safeSet.add(`${startR},${startC}`);
            for(let dr=-1; dr<=1; dr++){
                for(let dc=-1; dc<=1; dc++){
                    const nr = startR+dr; 
                    const nc = startC+dc;
                    if(nr>=0 && nr<chunk.h && nc>=0 && nc<chunk.w){
                        safeSet.add(`${nr},${nc}`);
                    }
                }
            }
        }

        while (minesPlaced < targetMines) {
            const r = Math.floor(Math.random() * chunk.h);
            const c = Math.floor(Math.random() * chunk.w);
            if (!chunk.grid[r][c].isMine && !safeSet.has(`${r},${c}`)) {
                chunk.grid[r][c].isMine = true;
                minesPlaced++;
            }
        }

        calculateNumbers(chunk);

        if (!checkBoundaryConsistency(chunk)) continue;

        if (checkChunkSolvability(chunk, isFirst, startR, startC)) {
            return true;
        }
    }
    return false;
}

function calculateNumbers(chunk) {
    chunk.grid.forEach(row => row.forEach(cell => {
        if (!cell.isMine) {
            cell.neighborMines = countGlobalMines(cell.gr, cell.gc);
        }
    }));
}

function countGlobalMines(gr, gc) {
    let count = 0;
    for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            const n = getGlobalCell(gr + dr, gc + dc);
            if (n && n.isMine) count++;
        }
    }
    return count;
}

function checkBoundaryConsistency(chunk) {
    // Iterate global border of this chunk
    // Range: [y-1, y+h] x [x-1, x+w]
    // Only check cells that are OUTSIDE this chunk but adjacent to it.
    
    for (let gr = chunk.y - 1; gr <= chunk.y + chunk.h; gr++) {
        for (let gc = chunk.x - 1; gc <= chunk.x + chunk.w; gc++) {
            // Skip internals
            if (chunk.contains(gr, gc)) continue;
            
            const nCell = getGlobalCell(gr, gc);
            if (nCell && nCell.isRevealed && !nCell.isMine) {
                // If this neighbor is revealed, ensure our new configuration matches its count
                const currentCount = countGlobalMines(nCell.gr, nCell.gc);
                if (currentCount !== nCell.neighborMines) return false;
            }
        }
    }
    return true;
}

// --- SOLVER ---

function checkChunkSolvability(chunk, isFirst, startR, startC) {
    const state = chunk.grid.map(row => row.map(c => ({
        ...c,
        status: 'hidden'
    })));

    if (isFirst) {
        vReveal(state[startR][startC]);
    }

    function getVCell(gr, gc) {
        // Internal?
        if (gr >= chunk.y && gr < chunk.y + chunk.h &&
            gc >= chunk.x && gc < chunk.x + chunk.w) {
            return state[gr - chunk.y][gc - chunk.x];
        }
        // External
        const real = getGlobalCell(gr, gc);
        if (real) {
            return {
                ...real,
                status: real.isRevealed ? 'revealed' : (real.isFlagged ? 'flagged' : 'hidden'),
                isExternal: true
            };
        }
        return null;
    }

    function getVNeighbors(vCell) {
        const res = [];
        for(let dr=-1; dr<=1; dr++){
            for(let dc=-1; dc<=1; dc++){
                if(dr===0 && dc===0) continue;
                const n = getVCell(vCell.gr + dr, vCell.gc + dc);
                if(n) res.push(n);
            }
        }
        return res;
    }

    function vReveal(vc) {
        if (vc.status !== 'hidden') return;
        vc.status = 'revealed';
        if (vc.isMine) return;
        if (vc.neighborMines === 0) {
            getVNeighbors(vc).forEach(n => !n.isExternal && vReveal(n));
        }
    }

    let progress = true;
    while (progress) {
        progress = false;
        let changed = false;

        const cellsToCheck = [];
        // Internal revealed
        state.flat().forEach(c => { if (c.status === 'revealed') cellsToCheck.push(c); });
        
        // External border revealed
        // Optimization: scan just the boundary
        for (let gr = chunk.y - 1; gr <= chunk.y + chunk.h; gr++) {
            for (let gc = chunk.x - 1; gc <= chunk.x + chunk.w; gc++) {
                if (!chunk.contains(gr, gc)) {
                    const nc = getGlobalCell(gr, gc);
                    if (nc && nc.isRevealed && isTouchingChunk(nc, chunk)) {
                        cellsToCheck.push({...nc, status: 'revealed', isExternal: true});
                    }
                }
            }
        }

        for (let cell of cellsToCheck) {
            if (cell.neighborMines > 0) {
                const neighbors = getVNeighbors(cell);
                const hidden = neighbors.filter(n => n.status === 'hidden');
                const flagged = neighbors.filter(n => n.status === 'flagged');
                
                if (hidden.length === 0) continue;

                if (flagged.length === cell.neighborMines) {
                    hidden.forEach(n => {
                        if (!n.isExternal) { vReveal(n); changed = true; }
                    });
                } else if (hidden.length + flagged.length === cell.neighborMines) {
                    hidden.forEach(n => {
                        if (!n.isExternal) { n.status = 'flagged'; changed = true; }
                    });
                }
            }
        }

        if (changed) { progress = true; continue; }
        if (runTankSolver(state, getVNeighbors)) { progress = true; }
    }

    for (let r = 0; r < chunk.h; r++) {
        for (let c = 0; c < chunk.w; c++) {
            if (state[r][c].status === 'hidden' && !state[r][c].isMine) return false;
        }
    }
    return true;
}

function isTouchingChunk(cell, chunk) {
    return (cell.gr >= chunk.y - 1 && cell.gr <= chunk.y + chunk.h &&
            cell.gc >= chunk.x - 1 && cell.gc <= chunk.x + chunk.w);
}

function runTankSolver(state, getNeighborsFunc) {
    const boundary = new Set();
    const constraints = [];
    const relevantCells = []; 

    // Gather revealed cells (internal + external boundary)
    state.flat().forEach(c => { if(c.status === 'revealed') relevantCells.push(c); });
    
    // External boundary
    const chunk = { // Mock chunk obj for bounds check in loop
        x: state[0][0].gc, y: state[0][0].gr, 
        w: state[0].length, h: state.length,
        contains: function(gr, gc) {
             return (gr >= this.y && gr < this.y + this.h && gc >= this.x && gc < this.x + this.w);
        }
    };
    
    for (let gr = chunk.y - 1; gr <= chunk.y + chunk.h; gr++) {
        for (let gc = chunk.x - 1; gc <= chunk.x + chunk.w; gc++) {
            if (!chunk.contains(gr, gc)) {
                const nc = getGlobalCell(gr, gc);
                if (nc && nc.isRevealed) relevantCells.push({...nc, status: 'revealed', isExternal: true});
            }
        }
    }

    for(let cell of relevantCells){
        if(cell.neighborMines > 0){
            const neighbors = getNeighborsFunc(cell);
            const hidden = neighbors.filter(n => n.status === 'hidden' && !n.isExternal);
            const flagged = neighbors.filter(n => n.status === 'flagged');
            
            if(hidden.length > 0){
                hidden.forEach(h => boundary.add(h));
                constraints.push({
                    cell: cell,
                    needed: cell.neighborMines - flagged.length,
                    targets: hidden
                });
            }
        }
    }

    if(boundary.size === 0) return false;
    
    const boundaryList = Array.from(boundary);
    const bMap = new Map();
    boundaryList.forEach((b, i) => bMap.set(b, i));
    const optConstraints = constraints.map(k => ({
        needed: k.needed,
        indices: k.targets.map(t => bMap.get(t))
    }));

    const canBeMine = new Array(boundaryList.length).fill(false);
    const canBeSafe = new Array(boundaryList.length).fill(false);
    const assignment = new Array(boundaryList.length).fill(-1);

    function solveRec(idx) {
        if(idx >= boundaryList.length){
            for(let i=0; i<boundaryList.length; i++){
                if(assignment[i] === 1) canBeMine[i] = true;
                else canBeSafe[i] = true;
            }
            return true;
        }
        assignment[idx] = 0;
        if(isValid(idx)) solveRec(idx + 1);
        assignment[idx] = 1;
        if(isValid(idx)) solveRec(idx + 1);
        assignment[idx] = -1;
    }

    function isValid(uptoIdx) {
        for(let k of optConstraints){
            let placed = 0;
            let unknown = 0;
            for(let idx of k.indices){
                if(assignment[idx] === 1) placed++;
                else if(assignment[idx] === -1) unknown++;
            }
            if(placed > k.needed) return false;
            if(placed + unknown < k.needed) return false;
        }
        return true;
    }

    solveRec(0);

    let madeProgress = false;
    for(let i=0; i<boundaryList.length; i++){
        const cell = boundaryList[i];
        if(canBeMine[i] && !canBeSafe[i]){
            cell.status = 'flagged';
            madeProgress = true;
        } else if(!canBeMine[i] && canBeSafe[i]){
            cell.status = 'revealed'; // Logic reveal
            madeProgress = true;
        }
    }
    return madeProgress;
}

// --- GAMEPLAY HELPERS ---

function handleTap(r, c, isLong) {
    if (isGameOver) return;
    
    const cell = getGlobalCell(r, c);
    if (!cell) return;

    const chunk = getChunkAt(r, c);
    
    if (chunk && !chunk.isGenerated && !isLong) {
        document.getElementById('loading').style.display = 'block';
        setTimeout(() => {
            const localR = cell.r; 
            const localC = cell.c;
            
            generateChunk(chunk, true, localR, localC).then(success => {
                document.getElementById('loading').style.display = 'none';
                if (success) {
                    chunk.isGenerated = true;
                    startTimer();
                    reveal(cell);
                    updateStatsHUD(chunk);
                } else {
                    alert("Failed to generate solvable start. Please try again.");
                }
            });
        }, 10);
        return;
    }

    if (isLong) {
        if (!cell.isRevealed) toggleFlag(cell);
        return;
    }

    if (cell.isFlagged) return;
    if (cell.isRevealed) tryChording(cell);
    else reveal(cell);
}

function toggleFlag(cell) {
    cell.isFlagged = !cell.isFlagged;
    if (navigator.vibrate) navigator.vibrate(70);
}

function reveal(cell) {
    if (cell.isRevealed || cell.isFlagged) return;
    
    cell.isRevealed = true;
    
    if (cell.isMine) {
        gameOver(false);
        return;
    }

    if (cell.neighborMines === 0) {
        const stack = [cell];
        while (stack.length > 0) {
            const current = stack.pop();
            for(let dr=-1; dr<=1; dr++){
                for(let dc=-1; dc<=1; dc++){
                    if(dr===0 && dc===0) continue;
                    const n = getGlobalCell(current.gr + dr, current.gc + dc);
                    if (n && !n.isRevealed && !n.isFlagged) {
                        n.isRevealed = true;
                        if (n.neighborMines === 0) stack.push(n);
                    }
                }
            }
        }
    }
    
    checkChunkComplete(cell);
}

function tryChording(cell) {
    let flags = 0;
    const neighbors = [];
    for(let dr=-1; dr<=1; dr++){
        for(let dc=-1; dc<=1; dc++){
            if(dr===0 && dc===0) continue;
            const n = getGlobalCell(cell.gr + dr, cell.gc + dc);
            if (n) {
                neighbors.push(n);
                if (n.isFlagged) flags++;
            }
        }
    }
    if (flags === cell.neighborMines) {
        neighbors.forEach(n => {
            if (!n.isRevealed && !n.isFlagged) reveal(n);
        });
    }
}

function checkChunkComplete(lastCell) {
    const chunk = getChunkAt(lastCell.gr, lastCell.gc);
    if (!chunk || chunk.isSolved) return;

    let unrevealedSafe = 0;
    chunk.grid.flat().forEach(c => {
        if (!c.isMine && !c.isRevealed) unrevealedSafe++;
    });

    if (unrevealedSafe === 0) {
        chunk.isSolved = true;
        solvedChunks++;
        
        chunk.grid.flat().forEach(c => {
            if (c.isMine) c.isFlagged = true;
        });

        // Spawn NEXT
        const directions = [[0, -1], [0, 1], [-1, 0], [1, 0]];
        // Randomize order
        directions.sort(() => Math.random() - 0.5);
        
        let spawned = false;
        for (let [dcy, dcx] of directions) {
            // Attempt spawn
            if (spawnChunk(chunk, dcx, dcy, false)) {
                spawned = true;
                panToChunk(activeChunk);
                break;
            }
        }
        
        updateStatsHUD(activeChunk);
    }
}

function panToChunk(chunk) {
    const chunkW = chunk.w * TILE_SIZE;
    const chunkH = chunk.h * TILE_SIZE;
    const cx = (chunk.x * TILE_SIZE) + chunkW/2;
    const cy = (chunk.y * TILE_SIZE) + chunkH/2;
    
    const screenW = canvas.width / dpr;
    const screenH = canvas.height / dpr;
    
    const tx = (screenW/2) - (cx * camera.scale);
    const ty = (screenH/2) - (cy * camera.scale);
    
    let frames = 0;
    const maxFrames = 60; 
    const sx = camera.x;
    const sy = camera.y;
    
    function step() {
        frames++;
        const t = frames / maxFrames;
        const ease = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; 
        
        camera.x = sx + (tx - sx) * ease;
        camera.y = sy + (ty - sy) * ease;
        
        if (frames < maxFrames) requestAnimationFrame(step);
    }
    step();
}

function gameOver(win) {
    isGameOver = true;
    stopTimer();
    
    chunks.forEach(chunk => {
        chunk.grid.flat().forEach(cell => {
            if (cell.isMine && !cell.isFlagged) cell.isRevealed = true;
        });
    });

    const modal = document.getElementById('game-over-modal');
    document.getElementById('modal-title').innerText = "Game Over";
    document.getElementById('modal-message').innerText = `Cleared ${solvedChunks} Sectors`;
    document.getElementById('restart-btn').innerText = "Try Again";
    modal.style.display = 'block';
}

function startTimer() {
    if (timerInterval) return;
    startTime = Date.now();
    timerInterval = setInterval(() => {
        const delta = Math.floor((Date.now() - startTime) / 1000);
        document.getElementById('timer').innerText = delta;
    }, 1000);
}

function stopTimer() {
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = null;
}

// --- RENDER LOOP ---

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    ctx.save();
    ctx.translate(camera.x, camera.y);
    ctx.scale(camera.scale, camera.scale);

    const screenW = canvas.width / dpr / camera.scale;
    const screenH = canvas.height / dpr / camera.scale;
    const viewX = -camera.x / camera.scale;
    const viewY = -camera.y / camera.scale;
    
    for (const chunk of chunks) {
        const chX = chunk.x * TILE_SIZE;
        const chY = chunk.y * TILE_SIZE;
        const chW = chunk.w * TILE_SIZE;
        const chH = chunk.h * TILE_SIZE;
        
        if (chX + chW < viewX || chX > viewX + screenW ||
            chY + chH < viewY || chY > viewY + screenH) {
            continue;
        }

        ctx.fillStyle = chunk.isSolved ? '#ffffff' : '#f0f2f5';
        ctx.fillRect(chX, chY, chW, chH);

        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = 'bold 24px sans-serif';
        
        chunk.grid.forEach(row => row.forEach(cell => {
            const x = cell.gc * TILE_SIZE;
            const y = cell.gr * TILE_SIZE;
            
            ctx.fillStyle = cell.isRevealed ? COLORS.revealed : COLORS.hidden;
            if (cell.isRevealed && cell.isMine) ctx.fillStyle = '#ef9a9a';
            ctx.fillRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);
            
            if (cell.isRevealed) {
                if (cell.isMine) {
                    ctx.fillStyle = COLORS.mine;
                    ctx.fillText('üí£', x + TILE_SIZE/2, y + TILE_SIZE/2 + 2);
                } else if (cell.neighborMines > 0) {
                    ctx.fillStyle = COLORS.nums[cell.neighborMines] || '#000';
                    ctx.fillText(cell.neighborMines, x + TILE_SIZE/2, y + TILE_SIZE/2 + 2);
                }
            } else if (cell.isFlagged) {
                 ctx.fillText('üö©', x + TILE_SIZE/2, y + TILE_SIZE/2 + 2);
            }
        }));
        
        ctx.strokeStyle = '#cfd8dc';
        ctx.lineWidth = 2;
        ctx.strokeRect(chX, chY, chW, chH);
    }

    ctx.restore();
    requestAnimationFrame(render);
}

// --- INPUT (Adapters) ---

function setupInput() {
    canvas.addEventListener('touchstart', onTouchStart, {passive: false});
    canvas.addEventListener('touchmove', onTouchMove, {passive: false});
    canvas.addEventListener('touchend', onTouchEnd, {passive: false});
    canvas.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('contextmenu', e => { e.preventDefault(); return false; });
    document.getElementById('restart-btn').addEventListener('click', resetGame);
}

function onTouchStart(e) {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        input.pointers.set(t.identifier, {x: t.clientX, y: t.clientY, startX: t.clientX, startY: t.clientY});
    }
    handlePointerDown();
}
function onTouchMove(e) {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        const p = input.pointers.get(t.identifier);
        if(p) { p.x = t.clientX; p.y = t.clientY; }
    }
    handlePointerMove();
}
function onTouchEnd(e) {
    e.preventDefault();
    handlePointerUp(); 
    for (let i = 0; i < e.changedTouches.length; i++) {
        input.pointers.delete(e.changedTouches[i].identifier);
    }
    if (input.pointers.size === 0) input.isDragging = false;
}
function onMouseDown(e) {
    if(e.button !== 0 && e.button !== 2) return;
    input.pointers.set(999, {x: e.clientX, y: e.clientY, startX: e.clientX, startY: e.clientY});
    handlePointerDown();
    if (e.button === 2) {
        input.isLongPress = true; 
        clearTimeout(input.longPressTimer);
    }
}
function onMouseMove(e) {
    const p = input.pointers.get(999);
    if(p) { p.x = e.clientX; p.y = e.clientY; handlePointerMove(); }
}
function onMouseUp(e) {
    if(input.pointers.has(999)) {
        handlePointerUp();
        input.pointers.delete(999);
        input.isDragging = false;
    }
}

function handlePointerDown() {
    if (input.pointers.size === 1) {
        input.isDragging = false;
        input.clickStartCamera = { ...camera };
        input.isLongPress = false;
        const p = Array.from(input.pointers.values())[0]; 
        
        input.longPressTimer = setTimeout(() => {
            if (!input.isDragging) {
                input.isLongPress = true;
                const wx = (p.x - camera.x) / camera.scale;
                const wy = (p.y - camera.y) / camera.scale;
                const c = Math.floor(wx / TILE_SIZE);
                const r = Math.floor(wy / TILE_SIZE);
                handleTap(r, c, true); 
            }
        }, 250); 
    } else if (input.pointers.size === 2) {
        clearTimeout(input.longPressTimer);
        input.isDragging = true;
        input.baseDist = getPinchDist();
        input.baseScale = camera.scale;
    }
}

function handlePointerMove() {
    const ptrs = Array.from(input.pointers.values());
    if (input.pointers.size === 1) {
        const p = ptrs[0];
        const dx = p.x - p.startX;
        const dy = p.y - p.startY;
        if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
            clearTimeout(input.longPressTimer);
            input.isDragging = true;
            camera.x += (p.x - input.lastX);
            camera.y += (p.y - input.lastY);
        }
        input.lastX = p.x;
        input.lastY = p.y;
    } else if (input.pointers.size === 2) {
        const dist = getPinchDist();
        const center = getPinchCenter();
        const newScale = input.baseScale * (dist / input.baseDist);
        const clampedScale = Math.max(0.1, Math.min(newScale, 3.0)); // Allow zooming out more for infinite
        
        const oldScale = camera.scale;
        const wx = (center.x - camera.x) / oldScale;
        const wy = (center.y - camera.y) / oldScale;
        
        camera.x = center.x - wx * newScale;
        camera.y = center.y - wy * newScale;
        camera.scale = newScale;

        input.lastX = center.x;
        input.lastY = center.y;
    }
}

function handlePointerUp() {
    clearTimeout(input.longPressTimer);
    if (!input.isDragging && input.pointers.size === 1 && !input.isLongPress) {
        const p = Array.from(input.pointers.values())[0];
        const wx = (p.x - camera.x) / camera.scale;
        const wy = (p.y - camera.y) / camera.scale;
        const c = Math.floor(wx / TILE_SIZE);
        const r = Math.floor(wy / TILE_SIZE);
        handleTap(r, c, false);
    }
}

function getPinchDist() {
    const ptrs = Array.from(input.pointers.values());
    return Math.hypot(ptrs[0].x - ptrs[1].x, ptrs[0].y - ptrs[1].y);
}
function getPinchCenter() {
    const ptrs = Array.from(input.pointers.values());
    return { x: (ptrs[0].x + ptrs[1].x)/2, y: (ptrs[0].y + ptrs[1].y)/2 };
}

init();
</script>
</body>
</html>